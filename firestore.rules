rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Users Collection
    match /users/{userId} {
      // Users can read their own profile and other users' profiles
      allow read: if request.auth != null;

      // Users can only write to their own profile
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // Friend Requests Collection
    match /friendRequests/{requestId} {
      // Allow users to create requests they're sending
      allow create: if request.auth != null &&
                      request.resource.data.fromUserId == request.auth.uid;

      // Allow users to read requests where they're the sender or receiver
      allow read: if request.auth != null &&
                    (resource.data.fromUserId == request.auth.uid ||
                     resource.data.toUserId == request.auth.uid);

      // Allow users to update requests they received
      allow update: if request.auth != null &&
                      resource.data.toUserId == request.auth.uid;

      // Allow users to delete their own sent requests
      allow delete: if request.auth != null &&
                      resource.data.fromUserId == request.auth.uid;
    }

    // Nous Requests Collection (Multi-Participant Support)
    match /nousRequests/{requestId} {
      // Allow users to create requests they're sending
      allow create: if request.auth != null &&
                      request.resource.data.fromUserId == request.auth.uid;

      // Allow users to read requests where they're the sender or a receiver
      // Support both old (toUserId) and new (toUserIds array) schema
      allow read: if request.auth != null &&
                    (resource.data.fromUserId == request.auth.uid ||
                     resource.data.toUserId == request.auth.uid ||
                     request.auth.uid in resource.data.get('toUserIds', []));

      // Allow users to update requests they received (to add their acceptance)
      // Support both old and new schema
      allow update: if request.auth != null &&
                      (resource.data.toUserId == request.auth.uid ||
                       request.auth.uid in resource.data.get('toUserIds', []));

      // Allow users to delete requests they sent or received
      allow delete: if request.auth != null &&
                      (resource.data.fromUserId == request.auth.uid ||
                       resource.data.toUserId == request.auth.uid ||
                       request.auth.uid in resource.data.get('toUserIds', []));
    }

    // Friendships Collection
    match /friendships/{friendshipId} {
      // Allow users to read friendships where they're one of the users
      allow read: if request.auth != null &&
                    (resource.data.user1Id == request.auth.uid ||
                     resource.data.user2Id == request.auth.uid);

      // Allow users to create friendships where they're one of the users
      allow create: if request.auth != null &&
                      (request.resource.data.user1Id == request.auth.uid ||
                       request.resource.data.user2Id == request.auth.uid);

      // Allow users to delete friendships where they're one of the users
      allow delete: if request.auth != null &&
                      (resource.data.user1Id == request.auth.uid ||
                       resource.data.user2Id == request.auth.uid);
    }

    // Shared Timers Collection
    match /sharedTimers/{timerId} {
      // Allow users to create shared timers where they're a participant
      allow create: if request.auth != null &&
                      request.auth.uid in request.resource.data.participants;

      // Allow participants to read shared timers
      allow read: if request.auth != null &&
                    request.auth.uid in resource.data.participants;

      // Allow participants to update shared timers (pause/resume/stop)
      allow update: if request.auth != null &&
                      request.auth.uid in resource.data.participants;

      // Allow participants to delete shared timers
      allow delete: if request.auth != null &&
                      request.auth.uid in resource.data.participants;
    }

    // Chat Messages Collection (for Nous together chat)
    match /chatMessages/{messageId} {
      // Allow users to create messages for shared timers they're in
      allow create: if request.auth != null &&
                      request.resource.data.senderId == request.auth.uid &&
                      request.auth.uid in request.resource.data.participants;

      // Allow users to read messages for shared timers they're participating in
      allow read: if request.auth != null &&
                    (request.auth.uid in resource.data.participants);

      // No updates or deletes for now (messages are immutable)
    }

    // Session Pings Collection (for Nous together pings)
    match /sessionPings/{pingId} {
      // Allow users to create pings for shared timers they're in
      allow create: if request.auth != null &&
                      request.resource.data.senderId == request.auth.uid &&
                      request.auth.uid in request.resource.data.participants;

      // Allow users to read pings for shared timers they're participating in
      allow read: if request.auth != null &&
                    (request.auth.uid in resource.data.participants);

      // No updates or deletes for now (pings are immutable)
    }

    // Session Invites Collection (for inviting friends to existing sessions)
    match /sessionInvites/{inviteId} {
      allow create: if request.auth != null && request.resource.data.fromUserId == request.auth.uid;
      allow read: if request.auth != null &&
        (resource.data.toUserId == request.auth.uid || resource.data.fromUserId == request.auth.uid);
      allow update: if request.auth != null && resource.data.toUserId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.fromUserId == request.auth.uid;
    }

    // Completed Nous Sessions (if you want to track them separately)
    match /completedNousSessions/{sessionId} {
      allow read: if request.auth != null && request.auth.uid in resource.data.participants;
      allow create: if request.auth != null;
    }

    // User document in artifacts (stores tree preferences, etc.)
    match /artifacts/{appId}/users/{userId} {
      // Allow users to read/write their own user document
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Sessions subcollection - allow reading for active user detection (suggested friends feature)
    match /artifacts/{appId}/users/{userId}/sessions/{sessionId} {
      // Allow users to read/write their own sessions
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Allow any authenticated user to read other users' sessions for suggested friends feature
      // This is safe because sessions only contain start/end times, duration, and topic names
      allow read: if request.auth != null;

      // Allow participants of a shared timer to write sessions to each other's collections
      // This is checked by verifying the session has isShared: true
      allow create: if request.auth != null &&
                      request.resource.data.isShared == true;
    }

    // Habits subcollection - users can only access their own habits
    match /artifacts/{appId}/users/{userId}/habits/{habitId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Active timers subcollection - users can only access their own timers
    match /artifacts/{appId}/users/{userId}/activeTimers/{timerId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Catch-all for any other artifacts subcollections
    match /artifacts/{appId}/users/{userId}/{subcollection}/{document} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
