<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mathematical Trees - Symmetrical Design</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f0f8ff; }
        .tree-container { margin: 20px 0; border: 1px solid #ddd; padding: 15px; display: inline-block; background-color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h3 { margin-top: 0; color: #2c3e50; }
        .info { font-size: 0.9em; color: #7f8c8d; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Mathematical Trees — Symmetrical Design</h1>
    <p>Symmetrical mathematical patterns with leaves attached to branches</p>
    <div id="trees-container"></div>

    <script>
        // Updated TREE_TYPES with symmetrical mathematical designs
        const TREE_TYPES = [
            { id: 'oak', name: 'Oak - Symmetrical Logic', requiredHours: 0, color: '#4a7c2c', leafColors: ['#3E7C17', '#5DAE49', '#A1C349', '#4a7c2c', '#6d9f4f'], branchColor: '#5A3E1B' },
            { id: 'maple', name: 'Maple - Symmetrical Fibonacci', requiredHours: 5, color: '#d94f04', leafColors: ['#FF4C29', '#FFB84C', '#D94F04', '#c2410c', '#f97316'], branchColor: '#6B2B06' },
            { id: 'cherry', name: 'Cherry Blossom - Symmetrical Order', requiredHours: 15, color: '#f9a8d4', leafColors: ['#F8C8DC', '#FADADD', '#FFD6E8', '#fbcfe8', '#fce7f3'], branchColor: '#8B5E3C' },
            { id: 'willow', name: 'Willow - Symmetrical Wave', requiredHours: 30, color: '#94a3b8', leafColors: ['#A3C9A8', '#6BA292', '#446A46', '#94a3b8', '#d1d5db'], branchColor: '#4E3B31' },
            { id: 'pine', name: 'Pine - Symmetrical Repetition', requiredHours: 50, color: '#166534', leafColors: ['#2C5F2D', '#166534', '#15803d', '#052e16', '#064e3b'], branchColor: '#3B2F2F' },
            { id: 'cypress', name: 'Cypress - Symmetrical Balance', requiredHours: 75, color: '#4d7c0f', leafColors: ['#557A46', '#A9C46C', '#7BA23F', '#65a30d', '#84cc16'], branchColor: '#4B3D28' },
            { id: 'birch', name: 'Birch - Symmetrical Elegance', requiredHours: 100, color: '#fde047', leafColors: ['#C7E6D7', '#fef08a', '#fde047', '#facc15', '#eab308'], branchColor: '#8E7C5D' },
            { id: 'sakura', name: 'Ancient Sakura - Symmetrical Mastery', requiredHours: 150, color: '#db2777', leafColors: ['#F8C8DC', '#FADADD', '#FFD6E8', '#fbcfe8', '#f9a8d4', '#f472b6', '#ec4899', '#e11d48'], branchColor: '#705243' },
            { id: 'baobab', name: 'Baobab - Symmetrical Wisdom', requiredHours: 250, color: '#4d7c0f', leafColors: ['#8ABF69', '#C8E7A7', '#EBF2C0', '#4d7c0f', '#a3e635'], branchColor: '#8B5A2B' },
            { id: 'magnolia', name: 'Magnolia - Perfect Symmetry', requiredHours: 400, color: '#e879f9', leafColors: ['#F6D6AD', '#EFBBCF', '#E6AACE', '#f5d0fe', '#f0abfc'], branchColor: '#7E6651' },
            { id: 'starry-night', name: 'Starry Night - Symmetrical Patterns', requiredHours: 600, color: '#8A2BE2', leafColors: ['#0B0B45', '#23238E', '#4B0082', '#8A2BE2', '#FFD700'], branchColor: '#2C3E50' },
            { id: 'redwood', name: 'Redwood - Symmetrical Stacking', requiredHours: 800, color: '#7f1d1d', leafColors: ['#7D6B91', '#B88B4A', '#A17C3A', '#450a0a', '#991b1b'], branchColor: '#4A2C2A' },
            { id: 'ginkgo', name: 'Ginkgo - Binary Symmetry', requiredHours: 1000, color: '#facc15', leafColors: ['#F4E409', '#FFD23F', '#F6AE2D', '#facc15', '#eab308'], branchColor: '#8C5E24' }
        ];

        class SymmetricalMathematicalTreeSVG {
            constructor(treeType, width = 400, height = 400) {
                this.treeType = treeType;
                this.width = width;
                this.height = height;
            }

            draw() {
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                svg.setAttribute("width", this.width);
                svg.setAttribute("height", this.height);
                svg.setAttribute("viewBox", `0 0 ${this.width} ${this.height}`);
                svg.setAttribute("style", "background: #f8f9fa");
                
                // Define symmetrical gradients
                this.addSymmetricalGradientDef(svg);
                
                // Draw symmetrical swaying trunk
                this.drawSymmetricalSwayingTrunk(svg);
                
                // Draw symmetrical curved branches
                this.drawSymmetricalCurvedBranches(svg);
                
                // Draw symmetrical mathematical leaves attached to branches
                this.drawSymmetricalMathematicalLeaves(svg);
                
                return svg;
            }

            addSymmetricalGradientDef(svg) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                const defs = document.createElementNS(svgNS, "defs");
                
                // Create radial gradient for leaves
                const gradient = document.createElementNS(svgNS, "radialGradient");
                gradient.setAttribute("id", `leafGradient-${this.treeType.id}`);
                gradient.setAttribute("cx", "40%");
                gradient.setAttribute("cy", "40%");
                gradient.setAttribute("r", "60%");
                
                // Add gradient stops for rich colors
                const stop1 = document.createElementNS(svgNS, "stop");
                stop1.setAttribute("offset", "0%");
                stop1.setAttribute("stop-color", this.treeType.leafColors[0]);
                stop1.setAttribute("stop-opacity", "0.95");
                gradient.appendChild(stop1);
                
                const stop2 = document.createElementNS(svgNS, "stop");
                stop2.setAttribute("offset", "30%");
                stop2.setAttribute("stop-color", this.treeType.leafColors[1]);
                stop2.setAttribute("stop-opacity", "0.88");
                gradient.appendChild(stop2);
                
                const stop3 = document.createElementNS(svgNS, "stop");
                stop3.setAttribute("offset", "60%");
                stop3.setAttribute("stop-color", this.treeType.leafColors[2]);
                stop3.setAttribute("stop-opacity", "0.80");
                gradient.appendChild(stop3);
                
                const stop4 = document.createElementNS(svgNS, "stop");
                stop4.setAttribute("offset", "100%");
                stop4.setAttribute("stop-color", this.treeType.leafColors[3] || this.treeType.leafColors[0]);
                stop4.setAttribute("stop-opacity", "0.70");
                gradient.appendChild(stop4);
                
                defs.appendChild(gradient);
                
                svg.appendChild(defs);
            }

            drawSymmetricalSwayingTrunk(svg) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Create a symmetrical curved trunk
                const trunkPath = document.createElementNS(svgNS, "path");
                
                // Trunk goes from bottom to about 40% up the tree
                const trunkHeight = this.height * 0.4;
                const trunkBottomY = this.height - 30;
                const trunkTopY = trunkBottomY - trunkHeight;
                
                // Create a gentle symmetrical curve to the side
                const swayAmount = 10;
                
                trunkPath.setAttribute("d", 
                    `M ${this.width/2} ${trunkBottomY} ` +
                    `C ${this.width/2 + swayAmount} ${trunkBottomY - trunkHeight * 0.6}, ` +
                    ` ${this.width/2 + swayAmount * 1.2} ${trunkTopY + 20}, ` +
                    ` ${this.width/2} ${trunkTopY}`
                );
                
                trunkPath.setAttribute("stroke", this.treeType.branchColor);
                trunkPath.setAttribute("stroke-width", "14");
                trunkPath.setAttribute("fill", "none");
                trunkPath.setAttribute("stroke-linecap", "round");
                trunkPath.setAttribute("stroke-linejoin", "round");
                trunkPath.setAttribute("stroke-opacity", "0.95");
                
                svg.appendChild(trunkPath);
            }

            drawSymmetricalCurvedBranches(svg) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Trunk top position
                const trunkHeight = this.height * 0.4;
                const trunkTopY = this.height - 30 - trunkHeight;
                const trunkTopX = this.width/2;
                
                // Draw symmetrical branches (left and right pairs)
                for (let level = 0; level < 4; level++) {
                    const y = trunkTopY + 10 + level * 15; // Vertical levels
                    
                    // Left and right branches at each level
                    for (let side = -1; side <= 1; side += 2) { // -1 for left, 1 for right
                        if (level === 0 && side === -1) continue; // Skip left at first level to create asymmetry for sway
                        
                        const angle = side * (0.3 + level * 0.2); // Increasing angle with level
                        const branchLength = 40 + level * 10;
                        const thickness = 3 - level * 0.5;
                        
                        // Calculate end points
                        const endX = trunkTopX + Math.sin(angle) * branchLength;
                        const endY = y - Math.cos(angle) * branchLength * 0.7;
                        
                        // Create curved path with Bézier curve
                        const controlX = trunkTopX + Math.sin(angle) * branchLength * 0.5;
                        const controlY = y - Math.cos(angle) * branchLength * 0.4;
                        
                        const branch = document.createElementNS(svgNS, "path");
                        branch.setAttribute("d", 
                            `M ${trunkTopX} ${y} ` +
                            `Q ${controlX} ${controlY}, ${endX} ${endY}`
                        );
                        branch.setAttribute("stroke", this.treeType.branchColor);
                        branch.setAttribute("stroke-width", thickness);
                        branch.setAttribute("fill", "none");
                        branch.setAttribute("stroke-linecap", "round");
                        branch.setAttribute("stroke-linejoin", "round");
                        branch.setAttribute("stroke-opacity", "0.9");
                        
                        svg.appendChild(branch);
                        
                        // Store branch endpoints for leaf attachment
                        if (!this.branchEnds) this.branchEnds = [];
                        this.branchEnds.push({x: endX, y: endY, level: level});
                    }
                }
                
                // Add more symmetrical branches for fuller look
                // Secondary branches from primary branches
                if (!this.branchEnds) this.branchEnds = [];
                const tempBranchEnds = [...this.branchEnds];
                
                for (let i = 0; i < tempBranchEnds.length; i++) {
                    if (tempBranchEnds[i].level < 3) { // Only add to branches up to level 2
                        // Add 2 small branches from each primary branch
                        for (let j = 0; j < 2; j++) {
                            const branch = tempBranchEnds[i];
                            const angle = (j === 0 ? -0.4 : 0.4) + (Math.random() - 0.5) * 0.2;
                            const subLength = 15 + Math.random() * 10;
                            const subThickness = 1.5 + Math.random() * 0.5;
                            
                            const subEndX = branch.x + Math.sin(angle) * subLength;
                            const subEndY = branch.y - Math.cos(angle) * subLength * 0.8;
                            
                            const subBranch = document.createElementNS(svgNS, "line");
                            subBranch.setAttribute("x1", branch.x);
                            subBranch.setAttribute("y1", branch.y);
                            subBranch.setAttribute("x2", subEndX);
                            subBranch.setAttribute("y2", subEndY);
                            subBranch.setAttribute("stroke", this.treeType.branchColor);
                            subBranch.setAttribute("stroke-width", subThickness);
                            subBranch.setAttribute("stroke-linecap", "round");
                            subBranch.setAttribute("stroke-opacity", "0.85");
                            
                            svg.appendChild(subBranch);
                            
                            this.branchEnds.push({x: subEndX, y: subEndY, level: branch.level + 1});
                        }
                    }
                }
            }

            drawSymmetricalMathematicalLeaves(svg) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Generate leaves based on symmetrical mathematical patterns
                // Each tree type has its own symmetrical pattern
                
                switch(this.treeType.id) {
                    case 'oak': // Symmetrical radial pattern
                        for (let ring = 0; ring < 10; ring++) {
                            const radius = 20 + ring * 6;
                            const leafCount = 6 + ring * 2;
                            
                            for (let i = 0; i < leafCount; i++) {
                                const angle = (i / leafCount) * Math.PI * 2;
                                const x = this.width/2 + 5 + Math.cos(angle) * radius;
                                const y = this.height/2 - 60 + Math.sin(angle) * radius * 0.8;
                                
                                // Attach to nearest branch
                                const nearestBranch = this.findNearestBranch(x, y);
                                if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 40) {
                                    if (Math.random() > 0.3) { // Space out leaves
                                        const sizeFactor = 0.8 + Math.random() * 0.4;
                                        this.drawSymmetricalLeaf(svg, x, y, sizeFactor, angle);
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'maple': // Symmetrical golden angle spiral
                        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                        for (let i = 0; i < 250; i++) {
                            const radius = 3.5 * Math.sqrt(i);
                            const theta = i * goldenAngle;
                            const x = this.width/2 + 5 + radius * Math.cos(theta);
                            const y = this.height/2 - 60 + radius * Math.sin(theta) * 0.8;
                            
                            if (radius < 80 && Math.random() > 0.4) {
                                const nearestBranch = this.findNearestBranch(x, y);
                                if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 45) {
                                    const sizeFactor = 0.7 + Math.random() * 0.4;
                                    this.drawSymmetricalLeaf(svg, x, y, sizeFactor, theta);
                                }
                            }
                        }
                        break;
                        
                    case 'cherry': // Symmetrical blossom clusters
                        for (let cluster = 0; cluster < 12; cluster++) {
                            const centerX = this.width/2 + 5 + (Math.random() - 0.5) * 40;
                            const centerY = this.height/2 - 60 + (Math.random() - 0.5) * 40;
                            
                            for (let j = 0; j < 15; j++) {
                                const angle = (j / 15) * Math.PI * 2;
                                const radius = Math.random() * 15;
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.8;
                                
                                const nearestBranch = this.findNearestBranch(x, y);
                                if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 35) {
                                    const sizeFactor = 0.7 + Math.random() * 0.3;
                                    this.drawSymmetricalLeaf(svg, x, y, sizeFactor, cluster * 15 + j);
                                }
                            }
                        }
                        break;
                        
                    case 'willow': // Symmetrical drooping wave pattern
                        for (let y = this.height/2 - 80; y < this.height/2 - 20; y += 8) {
                            for (let x = this.width/2 - 60; x < this.width/2 + 70; x += 10) {
                                const offsetX = x - (this.width/2 + 5);
                                const waveY = y + Math.sin(offsetX * 0.08) * 8 + Math.abs(offsetX) * 0.1;
                                
                                const nearestBranch = this.findNearestBranch(x, waveY);
                                if (nearestBranch && this.distance(x, waveY, nearestBranch.x, nearestBranch.y) < 30) {
                                    if (Math.random() > 0.5) { // Space out leaves
                                        const sizeFactor = 0.6 + Math.random() * 0.3;
                                        this.drawSymmetricalLeaf(svg, x, waveY, sizeFactor, y * 10 + x);
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'pine': // Symmetrical triangular lattice
                        for (let row = 0; row < 12; row++) {
                            for (let col = 0; col < 16; col++) {
                                const x = this.width/2 - 50 + col * 6 + (row % 2) * 3;
                                const y = this.height/2 - 70 + row * 6;
                                
                                if (Math.abs(x - (this.width/2 + 5)) < 50 && y < this.height/2 - 10) {
                                    const nearestBranch = this.findNearestBranch(x, y);
                                    if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 35) {
                                        if (Math.random() > 0.5) { // Space out leaves
                                            const sizeFactor = 0.6 + Math.random() * 0.3;
                                            this.drawSymmetricalLeaf(svg, x, y, sizeFactor, row * 16 + col);
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'cypress': // Symmetrical logarithmic spiral
                        for (let i = 0; i < 200; i++) {
                            const angle = i * 0.4;
                            const radius = 3 * Math.exp(0.03 * angle);
                            if (radius < 40) {
                                const x = this.width/2 + 5 + Math.cos(angle) * radius;
                                const y = this.height/2 - 60 + Math.sin(angle) * radius * 0.7;
                                
                                const nearestBranch = this.findNearestBranch(x, y);
                                if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 30) {
                                    if (Math.random() > 0.4) {
                                        const sizeFactor = 0.6 + Math.random() * 0.3;
                                        this.drawSymmetricalLeaf(svg, x, y, sizeFactor, i);
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'birch': // Symmetrical Voronoi-inspired pattern
                        for (let ring = 0; ring < 8; ring++) {
                            const radius = 15 + ring * 8;
                            const leafCount = 8 + ring * 2;
                            
                            for (let i = 0; i < leafCount; i++) {
                                const angle = (i / leafCount) * Math.PI * 2;
                                const x = this.width/2 + 5 + Math.cos(angle) * radius;
                                const y = this.height/2 - 60 + Math.sin(angle) * radius * 0.85;
                                
                                const nearestBranch = this.findNearestBranch(x, y);
                                if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 35) {
                                    if (Math.random() > 0.3) {
                                        const sizeFactor = 0.7 + Math.random() * 0.3;
                                        this.drawSymmetricalLeaf(svg, x, y, sizeFactor, angle);
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'sakura': // Symmetrical cherry blossom with many leaves
                        for (let ring = 0; ring < 9; ring++) {
                            const radius = 10 + ring * 6;
                            const leafCount = 10 + ring * 3;
                            
                            for (let i = 0; i < leafCount; i++) {
                                const angle = (i / leafCount) * Math.PI * 2;
                                const x = this.width/2 + 5 + Math.cos(angle) * radius;
                                const y = this.height/2 - 60 + Math.sin(angle) * radius * 0.85;
                                
                                // Always place sakura leaves for full appearance
                                const nearestBranch = this.findNearestBranch(x, y);
                                if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 40) {
                                    const sizeFactor = 0.7 + Math.random() * 0.3;
                                    this.drawSymmetricalSakuraLeaf(svg, x, y, sizeFactor, angle);
                                }
                            }
                        }
                        
                        // Additional clusters for fuller sakura look
                        for (let cluster = 0; cluster < 15; cluster++) {
                            const centerX = this.width/2 + 5 + (Math.random() - 0.5) * 35;
                            const centerY = this.height/2 - 60 + (Math.random() - 0.5) * 30;
                            
                            for (let j = 0; j < 12; j++) {
                                const angle = (j / 12) * Math.PI * 2;
                                const radius = Math.random() * 12;
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.8;
                                
                                const nearestBranch = this.findNearestBranch(x, y);
                                if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 35) {
                                    const sizeFactor = 0.6 + Math.random() * 0.3;
                                    this.drawSymmetricalSakuraLeaf(svg, x, y, sizeFactor, cluster * 12 + j);
                                }
                            }
                        }
                        break;
                        
                    case 'baobab': // Symmetrical strange attractor
                        for (let i = 0; i < 250; i++) {
                            let x = 0, y = 0;
                            let a = 1.4, b = 0.3;
                            
                            for (let j = 0; j < i * 2; j++) {
                                const oldX = x;
                                x = 1 - a * x * x + y;
                                y = b * oldX;
                            }
                            
                            const finalX = this.width/2 + 5 + x * 20;
                            const finalY = this.height/2 - 60 + y * 20;
                            
                            if (Math.abs(finalX - (this.width/2 + 5)) < 60 && Math.abs(finalY - (this.height/2 - 60)) < 50) {
                                const nearestBranch = this.findNearestBranch(finalX, finalY);
                                if (nearestBranch && this.distance(finalX, finalY, nearestBranch.x, nearestBranch.y) < 35) {
                                    if (Math.random() > 0.3) {
                                        const sizeFactor = 0.7 + Math.random() * 0.4;
                                        this.drawSymmetricalLeaf(svg, finalX, finalY, sizeFactor, i);
                                    }
                                }
                            }
                        }
                        break;
                        
                    default: // Symmetrical rose curve
                        const k = this.treeType.id === 'ginkgo' ? 2 : 3;
                        for (let i = 0; i < 250; i++) {
                            const angle = (i / 250) * Math.PI * 2 * k;
                            const radius = 45 * Math.cos(k * angle);
                            if (radius > 0) {
                                const x = this.width/2 + 5 + Math.cos(angle) * Math.abs(radius);
                                const y = this.height/2 - 60 + Math.sin(angle) * Math.abs(radius) * 0.8;
                                
                                const nearestBranch = this.findNearestBranch(x, y);
                                if (nearestBranch && this.distance(x, y, nearestBranch.x, nearestBranch.y) < 40) {
                                    if (Math.random() > 0.3) {
                                        const sizeFactor = 0.7 + 0.3 * Math.abs(Math.cos(angle));
                                        this.drawSymmetricalLeaf(svg, x, y, sizeFactor, angle);
                                    }
                                }
                            }
                        }
                        break;
                }
            }
            
            // Helper function to find the nearest branch to a point
            findNearestBranch(x, y) {
                if (!this.branchEnds) return null;
                
                let nearest = null;
                let minDist = Infinity;
                
                for (const branch of this.branchEnds) {
                    const dist = this.distance(x, y, branch.x, branch.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = branch;
                    }
                }
                
                return nearest;
            }
            
            // Helper function to calculate distance between two points
            distance(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }

            drawSymmetricalLeaf(svg, x, y, sizeFactor = 1.0, valueForColor = 0) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Smaller leaves as requested
                const baseSize = sizeFactor * (2.5 + Math.random() * 1.2);
                
                // Create circular leaf with gradient
                const leaf = document.createElementNS(svgNS, "circle");
                leaf.setAttribute("cx", x);
                leaf.setAttribute("cy", y);
                leaf.setAttribute("r", baseSize);
                leaf.setAttribute("fill", `url(#leafGradient-${this.treeType.id})`);
                leaf.setAttribute("opacity", "0.9");
                
                svg.appendChild(leaf);
            }

            drawSymmetricalSakuraLeaf(svg, x, y, sizeFactor = 1.0, valueForColor = 0) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Create sakura blossom
                const leaf = document.createElementNS(svgNS, "circle");
                leaf.setAttribute("cx", x);
                leaf.setAttribute("cy", y);
                leaf.setAttribute("r", sizeFactor * (2.2 + Math.random() * 1.0));
                leaf.setAttribute("fill", `url(#leafGradient-${this.treeType.id})`);
                leaf.setAttribute("opacity", "0.92");
                
                svg.appendChild(leaf);
            }
        }

        // Render all trees with symmetrical mathematical patterns
        const container = document.getElementById('trees-container');
        
        TREE_TYPES.forEach(treeType => {
            const treeContainer = document.createElement('div');
            treeContainer.className = 'tree-container';
            
            const title = document.createElement('h3');
            title.textContent = `${treeType.name} (Unlock at ${treeType.requiredHours} hours)`;
            treeContainer.appendChild(title);
            
            const info = document.createElement('div');
            info.className = 'info';
            info.textContent = `Symmetrical mathematical pattern with leaves attached to branches`;
            treeContainer.appendChild(info);
            
            const tree = new SymmetricalMathematicalTreeSVG(treeType);
            treeContainer.appendChild(tree.draw());
            
            container.appendChild(treeContainer);
        });
    </script>
</body>
</html>