<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mathematical Trees - Aesthetic Design</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f0f8ff; }
        .tree-container { margin: 20px 0; border: 1px solid #ddd; padding: 15px; display: inline-block; background-color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h3 { margin-top: 0; color: #2c3e50; }
        .info { font-size: 0.9em; color: #7f8c8d; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Mathematical Trees — Aesthetic Design</h1>
    <p>Combining mathematical patterns with aesthetic appeal like your reference</p>
    <div id="trees-container"></div>

    <script>
        // Updated TREE_TYPES with aesthetic mathematical designs
        const TREE_TYPES = [
            { id: 'oak', name: 'Oak - Logic & Beginnings', requiredHours: 0, color: '#4a7c2c', leafColors: ['#3E7C17', '#5DAE49', '#A1C349', '#4a7c2c', '#6d9f4f'], branchColor: '#5A3E1B' },
            { id: 'maple', name: 'Maple - Discovery & Fibonacci', requiredHours: 5, color: '#d94f04', leafColors: ['#FF4C29', '#FFB84C', '#D94F04', '#c2410c', '#f97316'], branchColor: '#6B2B06' },
            { id: 'cherry', name: 'Cherry Blossom - Mindfulness & Order', requiredHours: 15, color: '#f9a8d4', leafColors: ['#F8C8DC', '#FADADD', '#FFD6E8', '#fbcfe8', '#fce7f3'], branchColor: '#8B5E3C' },
            { id: 'willow', name: 'Willow - Adaptability & Wave Function', requiredHours: 30, color: '#94a3b8', leafColors: ['#A3C9A8', '#6BA292', '#446A46', '#94a3b8', '#d1d5db'], branchColor: '#4E3B31' },
            { id: 'pine', name: 'Pine - Discipline & Repetition', requiredHours: 50, color: '#166534', leafColors: ['#2C5F2D', '#166534', '#15803d', '#052e16', '#064e3b'], branchColor: '#3B2F2F' },
            { id: 'cypress', name: 'Cypress - Balance & Continuous Growth', requiredHours: 75, color: '#4d7c0f', leafColors: ['#557A46', '#A9C46C', '#7BA23F', '#65a30d', '#84cc16'], branchColor: '#4B3D28' },
            { id: 'birch', name: 'Birch - Elegance & Structured Randomness', requiredHours: 100, color: '#fde047', leafColors: ['#C7E6D7', '#fef08a', '#fde047', '#facc15', '#eab308'], branchColor: '#8E7C5D' },
            { id: 'sakura', name: 'Ancient Sakura - Mastery & Natural Beauty', requiredHours: 150, color: '#db2777', leafColors: ['#F8C8DC', '#FADADD', '#FFD6E8', '#fbcfe8', '#f9a8d4', '#f472b6', '#ec4899', '#e11d48'], branchColor: '#705243' },
            { id: 'baobab', name: 'Baobab - Wisdom & Chaotic Order', requiredHours: 250, color: '#4d7c0f', leafColors: ['#8ABF69', '#C8E7A7', '#EBF2C0', '#4d7c0f', '#a3e635'], branchColor: '#8B5A2B' },
            { id: 'magnolia', name: 'Magnolia - Harmony & Symmetry', requiredHours: 400, color: '#e879f9', leafColors: ['#F6D6AD', '#EFBBCF', '#E6AACE', '#f5d0fe', '#f0abfc'], branchColor: '#7E6651' },
            { id: 'starry-night', name: 'Starry Night - Cosmic Order & Patterns', requiredHours: 600, color: '#8A2BE2', leafColors: ['#0B0B45', '#23238E', '#4B0082', '#8A2BE2', '#FFD700'], branchColor: '#2C3E50' },
            { id: 'redwood', name: 'Redwood - Endurance & Stacked Growth', requiredHours: 800, color: '#7f1d1d', leafColors: ['#7D6B91', '#B88B4A', '#A17C3A', '#450a0a', '#991b1b'], branchColor: '#4A2C2A' },
            { id: 'ginkgo', name: 'Ginkgo - Ancient Wisdom & Binary', requiredHours: 1000, color: '#facc15', leafColors: ['#F4E409', '#FFD23F', '#F6AE2D', '#facc15', '#eab308'], branchColor: '#8C5E24' }
        ];

        class AestheticMathematicalTreeSVG {
            constructor(treeType, width = 400, height = 400) {
                this.treeType = treeType;
                this.width = width;
                this.height = height;
            }

            draw() {
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                svg.setAttribute("width", this.width);
                svg.setAttribute("height", this.height);
                svg.setAttribute("viewBox", `0 0 ${this.width} ${this.height}`);
                svg.setAttribute("style", "background: #f8f9fa");
                
                // Define aesthetic gradients
                this.addAestheticGradientDef(svg);
                
                // Draw aesthetic swaying trunk
                this.drawAestheticSwayingTrunk(svg);
                
                // Draw curved branches
                this.drawCurvedBranches(svg);
                
                // Draw mathematical leaves with spacing
                this.drawAestheticMathematicalLeaves(svg);
                
                return svg;
            }

            addAestheticGradientDef(svg) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                const defs = document.createElementNS(svgNS, "defs");
                
                // Create radial gradient for leaves
                const gradient = document.createElementNS(svgNS, "radialGradient");
                gradient.setAttribute("id", `leafGradient-${this.treeType.id}`);
                gradient.setAttribute("cx", "40%");
                gradient.setAttribute("cy", "40%");
                gradient.setAttribute("r", "60%");
                
                // Add gradient stops
                const stop1 = document.createElementNS(svgNS, "stop");
                stop1.setAttribute("offset", "0%");
                stop1.setAttribute("stop-color", this.treeType.leafColors[0]);
                stop1.setAttribute("stop-opacity", "0.95");
                gradient.appendChild(stop1);
                
                const stop2 = document.createElementNS(svgNS, "stop");
                stop2.setAttribute("offset", "30%");
                stop2.setAttribute("stop-color", this.treeType.leafColors[1]);
                stop2.setAttribute("stop-opacity", "0.88");
                gradient.appendChild(stop2);
                
                const stop3 = document.createElementNS(svgNS, "stop");
                stop3.setAttribute("offset", "60%");
                stop3.setAttribute("stop-color", this.treeType.leafColors[2]);
                stop3.setAttribute("stop-opacity", "0.80");
                gradient.appendChild(stop3);
                
                const stop4 = document.createElementNS(svgNS, "stop");
                stop4.setAttribute("offset", "100%");
                stop4.setAttribute("stop-color", this.treeType.leafColors[3] || this.treeType.leafColors[0]);
                stop4.setAttribute("stop-opacity", "0.70");
                gradient.appendChild(stop4);
                
                defs.appendChild(gradient);
                
                svg.appendChild(defs);
            }

            drawAestheticSwayingTrunk(svg) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Create a more aesthetic curved trunk
                const trunkPath = document.createElementNS(svgNS, "path");
                
                // Trunk goes from bottom to about 40% up the tree
                const trunkHeight = this.height * 0.4;
                const trunkBottomY = this.height - 30;
                const trunkTopY = trunkBottomY - trunkHeight;
                
                // Create a gentle curve to the side
                const swayAmount = 8;
                
                trunkPath.setAttribute("d", 
                    `M ${this.width/2} ${trunkBottomY} ` +
                    `C ${this.width/2 + swayAmount} ${trunkBottomY - trunkHeight * 0.6}, ` +
                    ` ${this.width/2 + swayAmount * 1.2} ${trunkTopY + 20}, ` +
                    ` ${this.width/2} ${trunkTopY}`
                );
                
                trunkPath.setAttribute("stroke", this.treeType.branchColor);
                trunkPath.setAttribute("stroke-width", "12");
                trunkPath.setAttribute("fill", "none");
                trunkPath.setAttribute("stroke-linecap", "round");
                trunkPath.setAttribute("stroke-linejoin", "round");
                trunkPath.setAttribute("stroke-opacity", "0.95");
                
                svg.appendChild(trunkPath);
            }

            drawCurvedBranches(svg) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Trunk top position
                const trunkHeight = this.height * 0.4;
                const trunkTopY = this.height - 30 - trunkHeight;
                const trunkTopX = this.width/2;
                
                // Draw multiple curved branches
                for (let i = 0; i < 8; i++) {
                    // Create various angles and curves
                    const angle = (i - 3.5) * 0.4; // From about -1.4 to +1.4 radians
                    const branchLength = 40 + Math.random() * 30;
                    const thickness = 2 + Math.random() * 2;
                    
                    // Calculate end points
                    const endX = trunkTopX + Math.sin(angle) * branchLength;
                    const endY = trunkTopY - Math.cos(angle) * branchLength;
                    
                    // Create curved path with Bézier curve
                    const controlX = trunkTopX + Math.sin(angle) * branchLength * 0.6 + (Math.random() - 0.5) * 15;
                    const controlY = trunkTopY - Math.cos(angle) * branchLength * 0.7 + (Math.random() - 0.5) * 10;
                    
                    const branch = document.createElementNS(svgNS, "path");
                    branch.setAttribute("d", 
                        `M ${trunkTopX} ${trunkTopY} ` +
                        `Q ${controlX} ${controlY}, ${endX} ${endY}`
                    );
                    branch.setAttribute("stroke", this.treeType.branchColor);
                    branch.setAttribute("stroke-width", thickness);
                    branch.setAttribute("fill", "none");
                    branch.setAttribute("stroke-linecap", "round");
                    branch.setAttribute("stroke-linejoin", "round");
                    branch.setAttribute("stroke-opacity", "0.9");
                    
                    svg.appendChild(branch);
                    
                    // Add secondary branches to some primary branches
                    if (i % 2 === 0) { // Every other branch gets a secondary branch
                        const subStartX = trunkTopX + Math.sin(angle) * branchLength * 0.6;
                        const subStartY = trunkTopY - Math.cos(angle) * branchLength * 0.6;
                        
                        const subAngle = angle + (Math.random() - 0.5) * 0.8;
                        const subLength = 20 + Math.random() * 15;
                        const subThickness = 1.5 + Math.random() * 1.0;
                        
                        const subEndX = subStartX + Math.sin(subAngle) * subLength;
                        const subEndY = subStartY - Math.cos(subAngle) * subLength;
                        
                        const subBranch = document.createElementNS(svgNS, "line");
                        subBranch.setAttribute("x1", subStartX);
                        subBranch.setAttribute("y1", subStartY);
                        subBranch.setAttribute("x2", subEndX);
                        subBranch.setAttribute("y2", subEndY);
                        subBranch.setAttribute("stroke", this.treeType.branchColor);
                        subBranch.setAttribute("stroke-width", subThickness);
                        subBranch.setAttribute("stroke-linecap", "round");
                        subBranch.setAttribute("stroke-opacity", "0.85");
                        
                        svg.appendChild(subBranch);
                    }
                }
            }

            drawAestheticMathematicalLeaves(svg) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Center position near the branches
                const centerX = this.width/2 + 5; // Slight offset to match sway
                const centerY = this.height / 2 - 60;
                
                // Create unique mathematical pattern for each tree type
                switch(this.treeType.id) {
                    case 'oak': // Symmetric radial with many small spaced leaves
                        for (let i = 0; i < 150; i++) {
                            const angle = (i / 150) * Math.PI * 2;
                            const radius = 20 + Math.sqrt(i) * 2.5;
                            if (radius < 70) {
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.8;
                                const sizeFactor = 0.8 + Math.random() * 0.3;
                                if (Math.random() > 0.4) { // Space out leaves
                                    this.drawAestheticLeaf(svg, x, y, sizeFactor, angle);
                                }
                            }
                        }
                        break;
                        
                    case 'maple': // Golden angle spiral with small spaced leaves
                        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                        for (let i = 0; i < 200; i++) {
                            const radius = 4 * Math.sqrt(i);
                            const theta = i * goldenAngle;
                            const x = centerX + radius * Math.cos(theta);
                            const y = centerY + radius * Math.sin(theta) * 0.8;
                            
                            if (radius < 80 && Math.random() > 0.3) {
                                const sizeFactor = 0.7 + Math.random() * 0.4;
                                this.drawAestheticLeaf(svg, x, y, sizeFactor, theta);
                            }
                        }
                        break;
                        
                    case 'cherry': // Concentrated blossom pattern
                        for (let i = 0; i < 180; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 5 + Math.sqrt(i) * 2.2;
                            if (radius < 60) {
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.8;
                                const sizeFactor = 0.7 + Math.random() * 0.3;
                                if (Math.random() > 0.3) {
                                    this.drawAestheticLeaf(svg, x, y, sizeFactor, i);
                                }
                            }
                        }
                        // Add concentrated blossom clusters
                        for (let cluster = 0; cluster < 8; cluster++) {
                            const clusterX = centerX + (Math.random() - 0.5) * 40;
                            const clusterY = centerY + (Math.random() - 0.5) * 35;
                            
                            for (let j = 0; j < 12; j++) {
                                const offsetX = (Math.random() - 0.5) * 12;
                                const offsetY = (Math.random() - 0.5) * 10;
                                const x = clusterX + offsetX;
                                const y = clusterY + offsetY;
                                const sizeFactor = 0.6 + Math.random() * 0.3;
                                
                                if (Math.abs(x - centerX) < 65 && Math.abs(y - centerY) < 55) {
                                    this.drawAestheticLeaf(svg, x, y, sizeFactor, cluster * 12 + j);
                                }
                            }
                        }
                        break;
                        
                    case 'willow': // Drooping pattern with many small spaced leaves
                        for (let i = 0; i < 250; i++) {
                            const x = centerX - 70 + (i * 0.56);
                            const offsetX = x - centerX;
                            const y = centerY + 20 + Math.sin(offsetX * 0.08) * 25 + Math.abs(offsetX) * 0.2;
                            const sizeFactor = 0.6 + Math.random() * 0.3;
                            if (Math.abs(offsetX) < 65 && Math.random() > 0.6) {
                                this.drawAestheticLeaf(svg, x, y, sizeFactor, i);
                            }
                        }
                        break;
                        
                    case 'pine': // Dense triangular pattern with small spaced leaves
                        for (let row = 0; row < 15; row++) {
                            for (let col = 0; col < 20; col++) {
                                if (Math.random() > 0.6) { // Sparse pattern
                                    const x = centerX - 50 + col * 5 + (row % 2) * 2.5;
                                    const y = centerY - 45 + row * 4;
                                    if (Math.abs(x - centerX) < 55 && y < centerY + 25) {
                                        const sizeFactor = 0.6 + Math.random() * 0.3;
                                        this.drawAestheticLeaf(svg, x, y, sizeFactor, row * 20 + col);
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'cypress': // Tall, narrow pattern
                        for (let i = 0; i < 180; i++) {
                            const angle = i * 0.5;
                            const radius = 4 * Math.exp(0.03 * angle);
                            if (radius < 45) {
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.7;
                                const sizeFactor = 0.6 + Math.random() * 0.3;
                                if (Math.random() > 0.4) {
                                    this.drawAestheticLeaf(svg, x, y, sizeFactor, i);
                                }
                            }
                        }
                        break;
                        
                    case 'birch': // Scattered symmetric pattern
                        for (let i = 0; i < 160; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 10 + Math.random() * 50;
                            if (Math.random() > 0.3) {
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.8;
                                const sizeFactor = 0.7 + Math.random() * 0.3;
                                this.drawAestheticLeaf(svg, x, y, sizeFactor, i);
                            }
                        }
                        break;
                        
                    case 'sakura': // Concentrated sakura with many small spaced pink leaves
                        for (let i = 0; i < 250; i++) { // Many more sakura leaves
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 5 + Math.sqrt(i) * 2.0;
                            
                            if (radius < 50) {
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.85;
                                const sizeFactor = 0.7 + Math.random() * 0.3;
                                
                                // Always place sakura leaves for full appearance but vary colors
                                this.drawAestheticSakuraLeaf(svg, x, y, sizeFactor, i);
                            }
                        }
                        
                        // Add additional clusters
                        for (let cluster = 0; cluster < 10; cluster++) {
                            const clusterX = centerX + (Math.random() - 0.5) * 35;
                            const clusterY = centerY + (Math.random() - 0.5) * 30;
                            
                            for (let j = 0; j < 10; j++) {
                                const offsetX = (Math.random() - 0.5) * 10;
                                const offsetY = (Math.random() - 0.5) * 8;
                                const x = clusterX + offsetX;
                                const y = clusterY + offsetY;
                                const sizeFactor = 0.6 + Math.random() * 0.3;
                                
                                if (Math.abs(x - centerX) < 55 && Math.abs(y - centerY) < 45) {
                                    this.drawAestheticSakuraLeaf(svg, x, y, sizeFactor, cluster * 10 + j);
                                }
                            }
                        }
                        break;
                        
                    case 'baobab': // Chaotic but spaced pattern
                        for (let i = 0; i < 180; i++) {
                            let x = 0, y = 0;
                            let a = 1.4, b = 0.3;
                            
                            for (let j = 0; j < i * 2; j++) {
                                const oldX = x;
                                x = 1 - a * x * x + y;
                                y = b * oldX;
                            }
                            
                            const finalX = centerX + x * 25;
                            const finalY = centerY + y * 25;
                            
                            if (Math.abs(finalX - centerX) < 65 && Math.abs(finalY - centerY) < 55 && Math.random() > 0.4) {
                                const sizeFactor = 0.7 + Math.random() * 0.4;
                                this.drawAestheticLeaf(svg, finalX, finalY, sizeFactor, i);
                            }
                        }
                        break;
                        
                    default: // Symmetric rose curve with many small spaced leaves
                        const k = this.treeType.id === 'ginkgo' ? 2 : 3;
                        for (let i = 0; i < 200; i++) {
                            const angle = (i / 200) * Math.PI * 2 * k;
                            const radius = 50 * Math.cos(k * angle);
                            const x = centerX + Math.cos(angle) * Math.abs(radius);
                            const y = centerY + Math.sin(angle) * Math.abs(radius) * 0.8;
                            
                            if (radius > 0 && Math.random() > 0.3) {
                                const sizeFactor = 0.7 + 0.3 * Math.abs(Math.cos(angle));
                                this.drawAestheticLeaf(svg, x, y, sizeFactor, angle);
                            }
                        }
                        break;
                }
            }

            drawAestheticLeaf(svg, x, y, sizeFactor = 1.0, valueForColor = 0) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Smaller leaves as requested
                const baseSize = sizeFactor * (3 + Math.random() * 1.5);
                
                // Create circular leaf with gradient
                const leaf = document.createElementNS(svgNS, "circle");
                leaf.setAttribute("cx", x);
                leaf.setAttribute("cy", y);
                leaf.setAttribute("r", baseSize);
                leaf.setAttribute("fill", `url(#leafGradient-${this.treeType.id})`);
                leaf.setAttribute("opacity", "0.85");
                
                svg.appendChild(leaf);
            }

            drawAestheticSakuraLeaf(svg, x, y, sizeFactor = 1.0, valueForColor = 0) {
                const svgNS = "http://www.w3.org/2000/svg";
                
                // Multiple pink gradients for sakura variety
                const gradientIndex = Math.floor(Math.random() * 2) + 1; // Use different stops
                const gradientId = `leafGradient-${this.treeType.id}`;
                
                // Create circular sakura blossom
                const leaf = document.createElementNS(svgNS, "circle");
                leaf.setAttribute("cx", x);
                leaf.setAttribute("cy", y);
                leaf.setAttribute("r", sizeFactor * (2.5 + Math.random() * 1.2));
                leaf.setAttribute("fill", `url(#leafGradient-${this.treeType.id})`);
                leaf.setAttribute("opacity", "0.9");
                
                svg.appendChild(leaf);
            }
        }

        // Render all trees with aesthetic mathematical patterns
        const container = document.getElementById('trees-container');
        
        TREE_TYPES.forEach(treeType => {
            const treeContainer = document.createElement('div');
            treeContainer.className = 'tree-container';
            
            const title = document.createElement('h3');
            title.textContent = `${treeType.name} (Unlock at ${treeType.requiredHours} hours)`;
            treeContainer.appendChild(title);
            
            const info = document.createElement('div');
            info.className = 'info';
            info.textContent = `Mathematical pattern: Aesthetic design with curved branches`;
            treeContainer.appendChild(info);
            
            const tree = new AestheticMathematicalTreeSVG(treeType);
            treeContainer.appendChild(tree.draw());
            
            container.appendChild(treeContainer);
        });
    </script>
</body>
</html>